"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.errorMessages = exports.rule = exports.name = void 0;

var _experimentalUtils = require("@typescript-eslint/experimental-utils");

//
// ─── HELPER FUNCTIONS ───────────────────────────────────────────────────────────
//
function hasMoreThen1Condition(node) {
  return node.left.type === _experimentalUtils.AST_NODE_TYPES.LogicalExpression || node.right.type === _experimentalUtils.AST_NODE_TYPES.LogicalExpression;
} //
// ─── RULE DECLARATIONS ──────────────────────────────────────────────────────────
//


const name = 'split-conditionals';
exports.name = name;

const createRule = _experimentalUtils.ESLintUtils.RuleCreator(() => 'https://github.com/fullstack-development/front-end-best-practices/blob/master/JS/goodPractice.md');

const errorMessages = {
  tooManyConditions: 'All checks containing more than one condition must be separated'
};
exports.errorMessages = errorMessages;
const meta = {
  type: 'suggestion',
  docs: {
    category: 'Best Practices',
    description: 'All checks containing more than one condition must be separated',
    recommended: false
  },
  messages: errorMessages,
  schema: []
};
const rule = createRule({
  name,
  meta,
  defaultOptions: [],

  create(context) {
    function checkLogicalExpression(node) {
      if (hasMoreThen1Condition(node)) {
        context.report({
          node,
          messageId: 'tooManyConditions'
        });
      }
    }

    function checkRule(node) {
      const testCondition = node.test;
      if (!testCondition) return;
      if (testCondition.type !== _experimentalUtils.AST_NODE_TYPES.LogicalExpression) return;
      checkLogicalExpression(testCondition);
    }

    return {
      IfStatement: checkRule,
      WhileStatement: checkRule,
      DoWhileStatement: checkRule,
      ForStatement: checkRule
    };
  }

});
exports.rule = rule;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcnVsZXMvc3BsaXQtY29uZGl0aW9uYWxzLnRzIl0sIm5hbWVzIjpbImhhc01vcmVUaGVuMUNvbmRpdGlvbiIsIm5vZGUiLCJsZWZ0IiwidHlwZSIsIkFTVF9OT0RFX1RZUEVTIiwiTG9naWNhbEV4cHJlc3Npb24iLCJyaWdodCIsIm5hbWUiLCJjcmVhdGVSdWxlIiwiRVNMaW50VXRpbHMiLCJSdWxlQ3JlYXRvciIsImVycm9yTWVzc2FnZXMiLCJ0b29NYW55Q29uZGl0aW9ucyIsIm1ldGEiLCJkb2NzIiwiY2F0ZWdvcnkiLCJkZXNjcmlwdGlvbiIsInJlY29tbWVuZGVkIiwibWVzc2FnZXMiLCJzY2hlbWEiLCJydWxlIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGUiLCJjb250ZXh0IiwiY2hlY2tMb2dpY2FsRXhwcmVzc2lvbiIsInJlcG9ydCIsIm1lc3NhZ2VJZCIsImNoZWNrUnVsZSIsInRlc3RDb25kaXRpb24iLCJ0ZXN0IiwiSWZTdGF0ZW1lbnQiLCJXaGlsZVN0YXRlbWVudCIsIkRvV2hpbGVTdGF0ZW1lbnQiLCJGb3JTdGF0ZW1lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFRQTtBQUNBO0FBQ0E7QUFFQSxTQUFTQSxxQkFBVCxDQUErQkMsSUFBL0IsRUFBMEU7QUFDeEUsU0FDRUEsSUFBSSxDQUFDQyxJQUFMLENBQVVDLElBQVYsS0FBbUJDLGtDQUFlQyxpQkFBbEMsSUFDQUosSUFBSSxDQUFDSyxLQUFMLENBQVdILElBQVgsS0FBb0JDLGtDQUFlQyxpQkFGckM7QUFJRCxDLENBRUQ7QUFDQTtBQUNBOzs7QUFFQSxNQUFNRSxJQUFJLEdBQUcsb0JBQWI7OztBQUVBLE1BQU1DLFVBQVUsR0FBR0MsK0JBQVlDLFdBQVosQ0FDakIsTUFDRSxrR0FGZSxDQUFuQjs7QUFLQSxNQUFNQyxhQUFhLEdBQUc7QUFDcEJDLEVBQUFBLGlCQUFpQixFQUNmO0FBRmtCLENBQXRCOztBQUtBLE1BQU1DLElBQThDLEdBQUc7QUFDckRWLEVBQUFBLElBQUksRUFBRSxZQUQrQztBQUVyRFcsRUFBQUEsSUFBSSxFQUFFO0FBQ0pDLElBQUFBLFFBQVEsRUFBRSxnQkFETjtBQUVKQyxJQUFBQSxXQUFXLEVBQ1QsaUVBSEU7QUFJSkMsSUFBQUEsV0FBVyxFQUFFO0FBSlQsR0FGK0M7QUFRckRDLEVBQUFBLFFBQVEsRUFBRVAsYUFSMkM7QUFTckRRLEVBQUFBLE1BQU0sRUFBRTtBQVQ2QyxDQUF2RDtBQVlBLE1BQU1DLElBQUksR0FBR1osVUFBVSxDQUFDO0FBQ3RCRCxFQUFBQSxJQURzQjtBQUV0Qk0sRUFBQUEsSUFGc0I7QUFHdEJRLEVBQUFBLGNBQWMsRUFBRSxFQUhNOztBQUl0QkMsRUFBQUEsTUFBTSxDQUFDQyxPQUFELEVBQVU7QUFDZCxhQUFTQyxzQkFBVCxDQUFnQ3ZCLElBQWhDLEVBQXdFO0FBQ3RFLFVBQUlELHFCQUFxQixDQUFDQyxJQUFELENBQXpCLEVBQWlDO0FBQy9Cc0IsUUFBQUEsT0FBTyxDQUFDRSxNQUFSLENBQWU7QUFDYnhCLFVBQUFBLElBRGE7QUFFYnlCLFVBQUFBLFNBQVMsRUFBRTtBQUZFLFNBQWY7QUFJRDtBQUNGOztBQUVELGFBQVNDLFNBQVQsQ0FDRTFCLElBREYsRUFNUTtBQUNOLFlBQU0yQixhQUFhLEdBQUczQixJQUFJLENBQUM0QixJQUEzQjtBQUVBLFVBQUksQ0FBQ0QsYUFBTCxFQUFvQjtBQUNwQixVQUFJQSxhQUFhLENBQUN6QixJQUFkLEtBQXVCQyxrQ0FBZUMsaUJBQTFDLEVBQTZEO0FBRTdEbUIsTUFBQUEsc0JBQXNCLENBQUNJLGFBQUQsQ0FBdEI7QUFDRDs7QUFFRCxXQUFPO0FBQ0xFLE1BQUFBLFdBQVcsRUFBRUgsU0FEUjtBQUVMSSxNQUFBQSxjQUFjLEVBQUVKLFNBRlg7QUFHTEssTUFBQUEsZ0JBQWdCLEVBQUVMLFNBSGI7QUFJTE0sTUFBQUEsWUFBWSxFQUFFTjtBQUpULEtBQVA7QUFNRDs7QUFuQ3FCLENBQUQsQ0FBdkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIFRTRVNUcmVlLFxyXG4gIEVTTGludFV0aWxzLFxyXG4gIEFTVF9OT0RFX1RZUEVTLFxyXG59IGZyb20gJ0B0eXBlc2NyaXB0LWVzbGludC9leHBlcmltZW50YWwtdXRpbHMnO1xyXG5cclxuaW1wb3J0IHsgUnVsZU1ldGFEYXRhIH0gZnJvbSAnLi4vLi4vdHlwZXMnO1xyXG5cclxuLy9cclxuLy8g4pSA4pSA4pSAIEhFTFBFUiBGVU5DVElPTlMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAXHJcbi8vXHJcblxyXG5mdW5jdGlvbiBoYXNNb3JlVGhlbjFDb25kaXRpb24obm9kZTogVFNFU1RyZWUuTG9naWNhbEV4cHJlc3Npb24pOiBib29sZWFuIHtcclxuICByZXR1cm4gKFxyXG4gICAgbm9kZS5sZWZ0LnR5cGUgPT09IEFTVF9OT0RFX1RZUEVTLkxvZ2ljYWxFeHByZXNzaW9uIHx8XHJcbiAgICBub2RlLnJpZ2h0LnR5cGUgPT09IEFTVF9OT0RFX1RZUEVTLkxvZ2ljYWxFeHByZXNzaW9uXHJcbiAgKTtcclxufVxyXG5cclxuLy9cclxuLy8g4pSA4pSA4pSAIFJVTEUgREVDTEFSQVRJT05TIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgFxyXG4vL1xyXG5cclxuY29uc3QgbmFtZSA9ICdzcGxpdC1jb25kaXRpb25hbHMnO1xyXG5cclxuY29uc3QgY3JlYXRlUnVsZSA9IEVTTGludFV0aWxzLlJ1bGVDcmVhdG9yKFxyXG4gICgpID0+XHJcbiAgICAnaHR0cHM6Ly9naXRodWIuY29tL2Z1bGxzdGFjay1kZXZlbG9wbWVudC9mcm9udC1lbmQtYmVzdC1wcmFjdGljZXMvYmxvYi9tYXN0ZXIvSlMvZ29vZFByYWN0aWNlLm1kJyxcclxuKTtcclxuXHJcbmNvbnN0IGVycm9yTWVzc2FnZXMgPSB7XHJcbiAgdG9vTWFueUNvbmRpdGlvbnM6XHJcbiAgICAnQWxsIGNoZWNrcyBjb250YWluaW5nIG1vcmUgdGhhbiBvbmUgY29uZGl0aW9uIG11c3QgYmUgc2VwYXJhdGVkJyxcclxufSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IG1ldGE6IFJ1bGVNZXRhRGF0YTxrZXlvZiB0eXBlb2YgZXJyb3JNZXNzYWdlcz4gPSB7XHJcbiAgdHlwZTogJ3N1Z2dlc3Rpb24nLFxyXG4gIGRvY3M6IHtcclxuICAgIGNhdGVnb3J5OiAnQmVzdCBQcmFjdGljZXMnLFxyXG4gICAgZGVzY3JpcHRpb246XHJcbiAgICAgICdBbGwgY2hlY2tzIGNvbnRhaW5pbmcgbW9yZSB0aGFuIG9uZSBjb25kaXRpb24gbXVzdCBiZSBzZXBhcmF0ZWQnLFxyXG4gICAgcmVjb21tZW5kZWQ6IGZhbHNlLFxyXG4gIH0sXHJcbiAgbWVzc2FnZXM6IGVycm9yTWVzc2FnZXMsXHJcbiAgc2NoZW1hOiBbXSxcclxufTtcclxuXHJcbmNvbnN0IHJ1bGUgPSBjcmVhdGVSdWxlKHtcclxuICBuYW1lLFxyXG4gIG1ldGEsXHJcbiAgZGVmYXVsdE9wdGlvbnM6IFtdLFxyXG4gIGNyZWF0ZShjb250ZXh0KSB7XHJcbiAgICBmdW5jdGlvbiBjaGVja0xvZ2ljYWxFeHByZXNzaW9uKG5vZGU6IFRTRVNUcmVlLkxvZ2ljYWxFeHByZXNzaW9uKTogdm9pZCB7XHJcbiAgICAgIGlmIChoYXNNb3JlVGhlbjFDb25kaXRpb24obm9kZSkpIHtcclxuICAgICAgICBjb250ZXh0LnJlcG9ydCh7XHJcbiAgICAgICAgICBub2RlLFxyXG4gICAgICAgICAgbWVzc2FnZUlkOiAndG9vTWFueUNvbmRpdGlvbnMnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tSdWxlKFxyXG4gICAgICBub2RlOlxyXG4gICAgICAgIHwgVFNFU1RyZWUuSWZTdGF0ZW1lbnRcclxuICAgICAgICB8IFRTRVNUcmVlLldoaWxlU3RhdGVtZW50XHJcbiAgICAgICAgfCBUU0VTVHJlZS5Eb1doaWxlU3RhdGVtZW50XHJcbiAgICAgICAgfCBUU0VTVHJlZS5Gb3JTdGF0ZW1lbnQsXHJcbiAgICApOiB2b2lkIHtcclxuICAgICAgY29uc3QgdGVzdENvbmRpdGlvbiA9IG5vZGUudGVzdDtcclxuXHJcbiAgICAgIGlmICghdGVzdENvbmRpdGlvbikgcmV0dXJuO1xyXG4gICAgICBpZiAodGVzdENvbmRpdGlvbi50eXBlICE9PSBBU1RfTk9ERV9UWVBFUy5Mb2dpY2FsRXhwcmVzc2lvbikgcmV0dXJuO1xyXG5cclxuICAgICAgY2hlY2tMb2dpY2FsRXhwcmVzc2lvbih0ZXN0Q29uZGl0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBJZlN0YXRlbWVudDogY2hlY2tSdWxlLFxyXG4gICAgICBXaGlsZVN0YXRlbWVudDogY2hlY2tSdWxlLFxyXG4gICAgICBEb1doaWxlU3RhdGVtZW50OiBjaGVja1J1bGUsXHJcbiAgICAgIEZvclN0YXRlbWVudDogY2hlY2tSdWxlLFxyXG4gICAgfTtcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCB7IG5hbWUsIHJ1bGUsIGVycm9yTWVzc2FnZXMgfTtcclxuIl19